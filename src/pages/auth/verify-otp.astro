---
/**
 * Authentication OTP Verification Endpoint (Server-Side)
 *
 * This endpoint handles the custom OTP authentication flow for login/registration:
 * 1. Validates OTP token from query params
 * 2. Checks if user exists in the system
 * 3. Creates account for new users (with email_confirm=true)
 * 4. Creates authenticated session for the user
 * 5. Redirects to specified page or homepage
 *
 * This is 100% server-side and passwordless.
 */
import { createSupabaseServerClient } from "@/db/supabase.client";
import { createSupabaseAdminClient } from "@/db/supabase.admin.client";
import { secureError } from "@/lib/server/logger.service";
import { ENV } from "@/lib/server/env-validation.service";

export const prerender = false;

// Get OTP from query params
const otp = Astro.url.searchParams.get("otp");

// Get locale from cookie or use default
const locale = Astro.cookies.get("locale")?.value || ENV.PUBLIC_DEFAULT_LOCALE;

// Validate OTP parameter
if (!otp || typeof otp !== "string" || otp.length !== 64) {
  secureError("Invalid OTP format", { hasOtp: !!otp, otpLength: otp?.length });
  return Astro.redirect(`/${locale}/auth/error?error=invalid_link`);
}

// Create admin client for database operations
const adminClient = createSupabaseAdminClient();

try {
  // Step 1: Fetch and validate OTP from database
  const { data: otpRecord, error: otpFetchError } = await adminClient
    .from("auth_otp")
    .select("*")
    .eq("otp_token", otp)
    .maybeSingle();

  if (otpFetchError) {
    secureError("Error fetching OTP record", otpFetchError);
    return Astro.redirect(`/${locale}/auth/error?error=verification_failed`);
  }

  if (!otpRecord) {
    secureError("OTP not found", { otp });
    return Astro.redirect(`/${locale}/auth/error?error=invalid_link`);
  }

  // Step 2: Check if OTP has expired
  if (new Date(otpRecord.expires_at) < new Date()) {
    secureError("OTP expired", { otp, expiresAt: otpRecord.expires_at });
    return Astro.redirect(`/${locale}/auth/error?error=link_expired`);
  }

  // Step 3: Check if OTP has already been used
  if (otpRecord.used) {
    secureError("OTP already used", { otp });
    return Astro.redirect(`/${locale}/auth/error?error=link_used`);
  }

  const email = otpRecord.email;
  const redirectTo = otpRecord.redirect_to;

  // Step 4: Check if user exists
  let userId: string | null = null;
  let userExists = false;

  try {
    let page = 1;
    const perPage = 1000;
    let hasMoreUsers = true;

    while (hasMoreUsers && !userExists) {
      const { data: usersList, error: listError } = await adminClient.auth.admin.listUsers({
        page,
        perPage,
      });

      if (listError) {
        secureError("Error listing users", listError);
        break;
      }

      if (!usersList?.users || usersList.users.length === 0) {
        hasMoreUsers = false;
        break;
      }

      for (const user of usersList.users) {
        if (user.email && user.email.toLowerCase() === email.toLowerCase()) {
          userExists = true;
          userId = user.id;
          break;
        }
      }

      if (usersList.users.length < perPage) {
        hasMoreUsers = false;
      } else {
        page++;
      }
    }
  } catch (err) {
    secureError("Error checking user existence", err);
    return Astro.redirect(`/${locale}/auth/error?error=unexpected_error`);
  }

  // Step 5: Create account for new users
  if (!userExists) {
    try {
      const { data: newUser, error: createError } = await adminClient.auth.admin.createUser({
        email,
        email_confirm: true, // Auto-confirm email
        user_metadata: {
          registered_at: new Date().toISOString(),
        },
      });

      if (createError) {
        // Check if error is because user already exists
        const errMsg = createError.message || "";
        if (
          !errMsg.includes("already been registered") &&
          !errMsg.includes("already registered") &&
          createError.code !== "email_exists"
        ) {
          throw createError;
        }
        // User exists, try to find them again
        const { data: existingUser } = await adminClient.auth.admin.getUserByEmail(email);
        userId = existingUser?.user?.id || null;
      } else {
        userId = newUser?.user?.id || null;
      }
    } catch (createErr) {
      secureError("Error creating user account", createErr);
      return Astro.redirect(`/${locale}/auth/error?error=account_creation_failed`);
    }
  }

  if (!userId) {
    secureError("Failed to get user ID", { email });
    return Astro.redirect(`/${locale}/auth/error?error=unexpected_error`);
  }

  // Step 6: Create session for the user using generateLink + verifyOtp
  const { data: linkData, error: linkError } = await adminClient.auth.admin.generateLink({
    type: "magiclink",
    email,
  });

  if (linkError || !linkData) {
    secureError("Error generating magic link", linkError);
    return Astro.redirect(`/${locale}/auth/error?error=session_creation_failed`);
  }

  // The hashed_token from generateLink can be used with verifyOtp
  const hashedToken = linkData.properties.hashed_token;

  if (!hashedToken) {
    secureError("No hashed token in link data", { linkData });
    return Astro.redirect(`/${locale}/auth/error?error=session_creation_failed`);
  }

  // Create Supabase client and verify with the hashed token
  const supabase = createSupabaseServerClient(Astro.request, Astro.cookies);

  const { data, error: verifyError } = await supabase.auth.verifyOtp({
    token_hash: hashedToken,
    type: "magiclink",
  });

  if (verifyError || !data.session) {
    secureError("Error creating session with hashed token", verifyError);
    return Astro.redirect(`/${locale}/auth/error?error=session_creation_failed`);
  }

  // Step 7: Mark OTP as used
  await adminClient.from("auth_otp").update({ used: true }).eq("otp_token", otp);

  // Step 8: Redirect to specified page or homepage
  const redirectUrl = redirectTo || `/${locale}`;
  return Astro.redirect(redirectUrl);
} catch (err) {
  secureError("Unexpected error in verify-otp", err);
  return Astro.redirect(`/${locale}/auth/error?error=unexpected_error`);
}
---
