-- migration: 20251014100000_initial_schema.sql
-- description: complete database schema for the tour planner application.
-- this migration includes:
--   - creation of all tables: profiles, tours, participants, comments, votes, invitations, tags, tour_tags.
--   - definition of custom enum types for statuses.
--   - setup of row-level security (rls) policies for all tables.
--   - creation of indexes for performance.
--   - implementation of triggers for automatic profile creation and handling user deletion.
--   - insertion of a special 'anonymized' user profile for maintaining comment integrity.
--   - helper functions for RLS and tour creation.

-- a note on the profiles table:
-- the foreign key constraint from 'public.profiles.id' to 'auth.users.id' has been omitted
-- to allow for the creation of a special 'anonymized' user record (uuid: 00000000-...).
-- data integrity for regular users is maintained by a trigger that creates a profile
-- for each new user in 'auth.users'.

begin;

-- custom types
create type public.tour_status as enum ('active', 'archived');
create type public.invitation_status as enum ('pending', 'accepted', 'declined');

-- profiles table
create table public.profiles (
    id uuid primary key,
    display_name text,
    language text not null default 'en-US',
    theme text not null default 'system',
    onboarding_completed boolean not null default false,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);
comment on table public.profiles is 'stores user profile information, extending the auth.users table.';
comment on column public.profiles.language is 'User preferred language in full locale format (e.g., en-US, pl-PL). Must match locale codes used in URLs and i18n configuration.';

alter table public.profiles enable row level security;

-- tours table
create table public.tours (
    id uuid primary key default gen_random_uuid(),
    owner_id uuid not null references public.profiles(id),
    title text not null check (length(title) > 0),
    destination text not null check (length(destination) > 0),
    description text,
    start_date timestamptz not null,
    end_date timestamptz not null,
    participant_limit integer check (participant_limit > 0),
    like_threshold integer check (like_threshold > 0),
    are_votes_hidden boolean not null default false,
    status public.tour_status not null default 'active',
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);
comment on table public.tours is 'contains all information about a tour.';

alter table public.tours enable row level security;

-- participants table
create table public.participants (
    tour_id uuid not null references public.tours(id) on delete cascade,
    user_id uuid not null references public.profiles(id) on delete cascade,
    joined_at timestamptz not null default now(),
    primary key (tour_id, user_id)
);
comment on table public.participants is 'joining table for the many-to-many relationship between profiles and tours.';

alter table public.participants enable row level security;

-- comments table
create table public.comments (
    id uuid primary key default gen_random_uuid(),
    tour_id uuid not null references public.tours(id) on delete cascade,
    user_id uuid not null references public.profiles(id) on delete set default default '00000000-0000-0000-0000-000000000000',
    content text not null check (length(content) > 0),
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);
comment on table public.comments is 'stores comments made by users on tours.';

alter table public.comments enable row level security;

-- votes table
create table public.votes (
    tour_id uuid not null references public.tours(id) on delete cascade,
    user_id uuid not null references public.profiles(id) on delete cascade,
    created_at timestamptz not null default now(),
    primary key (tour_id, user_id)
);
comment on table public.votes is 'stores "likes" from users for a specific tour.';

alter table public.votes enable row level security;

-- invitations table
create table public.invitations (
    id uuid primary key default gen_random_uuid(),
    tour_id uuid not null references public.tours(id) on delete cascade,
    inviter_id uuid not null references public.profiles(id) on delete cascade,
    email text not null,
    status public.invitation_status not null default 'pending',
    created_at timestamptz not null default now()
);
comment on table public.invitations is 'tracks invitations sent to users to join a tour.';

alter table public.invitations enable row level security;

-- tags table
create table public.tags (
    id bigint primary key generated by default as identity,
    name text not null unique check (length(name) > 0)
);
comment on table public.tags is 'stores unique tags for categorizing archived tours.';

alter table public.tags enable row level security;

-- tour_tags table
create table public.tour_tags (
    tour_id uuid not null references public.tours(id) on delete cascade,
    tag_id bigint not null references public.tags(id) on delete cascade,
    primary key (tour_id, tag_id)
);
comment on table public.tour_tags is 'joining table for the many-to-many relationship between tours and tags.';

alter table public.tour_tags enable row level security;

-- anonymized user record
insert into public.profiles (id, display_name)
values ('00000000-0000-0000-0000-000000000000', 'Anonymized User');

-- indexes
create index on public.participants (user_id);
create index on public.comments (tour_id, created_at desc);
create index on public.tour_tags (tag_id);
create index on public.invitations (tour_id, email);
-- Performance indexes
create index if not exists idx_tours_status on public.tours (status);
create index if not exists idx_tours_owner_id on public.tours (owner_id);

-- function to create a profile for a new user
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id)
  values (new.id);
  return new;
end;
$$;

-- trigger for new user profile creation
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- function to handle user deletion
create or replace function public.handle_user_deletion()
returns trigger
language plpgsql
security definer set search_path = public
as $$
declare
  rec record;
  new_owner_id uuid;
begin
  -- transfer ownership of tours or delete them
  for rec in select id from tours where owner_id = old.id loop
    new_owner_id := (
      select user_id from participants
      where tour_id = rec.id and user_id != old.id
      order by joined_at asc
      limit 1
    );
    if new_owner_id is not null then
      update tours set owner_id = new_owner_id where id = rec.id;
    else
      delete from tours where id = rec.id;
    end if;
  end loop;

  -- delete the user's profile
  delete from public.profiles where id = old.id;
  
  return old;
end;
$$;

-- trigger for user deletion
create trigger on_auth_user_deleted
  before delete on auth.users
  for each row execute procedure public.handle_user_deletion();

-- function to check if a user is a participant in a tour.
-- this function uses security definer to bypass rls and avoid recursion.
create or replace function public.is_participant(tour_id_to_check uuid, user_id_to_check uuid)
returns boolean
language plpgsql
security definer
as $$
begin
  return exists (
    select 1
    from public.participants
    where tour_id = tour_id_to_check and user_id = user_id_to_check
  );
end;
$$;

-- function to clean up unconfirmed users older than 24 hours
create or replace function public.cleanup_unconfirmed_users()
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  deleted_count integer;
begin
  -- Delete users who:
  -- 1. Have not confirmed their email (confirmed_at IS NULL)
  -- 2. Were created more than 24 hours ago
  -- Note: This will also cascade delete to public.profiles due to ON DELETE CASCADE
  delete from auth.users
  where confirmed_at is null
    and created_at < now() - interval '24 hours';

  -- Get the number of deleted rows
  get diagnostics deleted_count = row_count;

  -- Log the cleanup operation
  if deleted_count > 0 then
    raise notice 'Cleaned up % unconfirmed user(s)', deleted_count;
  end if;
end;
$$;

-- Grant execute permission to postgres role
grant execute on function public.cleanup_unconfirmed_users() to postgres;

-- Comment on the function
comment on function public.cleanup_unconfirmed_users() is
  'Deletes unconfirmed users older than 24 hours to prevent database bloat from abandoned signups';

-- function to insert tours that bypasses RLS
create or replace function public.create_tour(
  p_title text,
  p_destination text,
  p_description text,
  p_start_date timestamptz,
  p_end_date timestamptz,
  p_participant_limit integer default null,
  p_like_threshold integer default null
)
returns table (
  id uuid,
  owner_id uuid,
  title text,
  destination text,
  description text,
  start_date timestamptz,
  end_date timestamptz,
  participant_limit integer,
  like_threshold integer,
  are_votes_hidden boolean,
  status text,
  created_at timestamptz
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid;
  v_tour_id uuid;
begin
  -- Get the current user's ID
  v_user_id := auth.uid();

  -- Ensure user is authenticated
  if v_user_id is null then
    raise exception 'User must be authenticated to create a tour';
  end if;

  -- Insert the tour
  insert into public.tours (
    owner_id,
    title,
    destination,
    description,
    start_date,
    end_date,
    participant_limit,
    like_threshold
  ) values (
    v_user_id,
    p_title,
    p_destination,
    p_description,
    p_start_date,
    p_end_date,
    p_participant_limit,
    p_like_threshold
  )
  returning tours.id into v_tour_id;

  -- Add the owner as a participant
  insert into public.participants (tour_id, user_id)
  values (v_tour_id, v_user_id);

  -- Return the created tour
  return query
  select
    t.id,
    t.owner_id,
    t.title,
    t.destination,
    t.description,
    t.start_date,
    t.end_date,
    t.participant_limit,
    t.like_threshold,
    t.are_votes_hidden,
    t.status::text,
    t.created_at
  from public.tours t
  where t.id = v_tour_id;
end;
$$;

-- Grant execute to authenticated users
grant execute on function public.create_tour to authenticated;

-- Add comment
comment on function public.create_tour is 'Creates a new tour and adds the creator as a participant. Uses SECURITY DEFINER to bypass RLS evaluation issues with server-side clients.';

-- rls policies

-- profiles
create policy "users can view profiles in their tours" on public.profiles
  for select using (
    -- User can see their own profile
    auth.uid() = id
    or
    -- User can see profiles of participants in tours they're in
    exists (
      select 1
      from public.participants p1
      inner join public.participants p2 on p1.tour_id = p2.tour_id
      where p1.user_id = auth.uid()  -- Current user is a participant
        and p2.user_id = profiles.id  -- This profile belongs to another participant in same tour
    )
  );

comment on policy "users can view profiles in their tours" on public.profiles is
  'SECURITY MODEL: Profile Visibility in Tours. Allows users to view their own profile and profiles of other participants in tours they are part of. This enables displaying participant avatars and names in tour lists.';

create policy "users can update their own profile" on public.profiles
  for update using (auth.uid() = id) with check (auth.uid() = id);

-- tours
create policy "users can view tours they are a participant in" on public.tours
  for select using (exists (select 1 from participants where tour_id = tours.id and user_id = auth.uid()));

create policy "authenticated users can create tours" on public.tours
  for insert with check (auth.role() = 'authenticated');

create policy "tour owners can update their tours" on public.tours
  for update using (owner_id = auth.uid()) with check (owner_id = auth.uid());

create policy "tour owners can delete their tours" on public.tours
  for delete using (owner_id = auth.uid());

-- participants
create policy "users can view participants of tours they are in" on public.participants
  for select using (public.is_participant(tour_id, auth.uid()));

create policy "tour owners can add new participants" on public.participants
  for insert with check (exists (select 1 from tours where id = participants.tour_id and owner_id = auth.uid()));

create policy "users can leave tours, and owners can remove participants" on public.participants
  for delete using (user_id = auth.uid() or exists (select 1 from tours where id = participants.tour_id and owner_id = auth.uid()));

-- comments
create policy "users can read comments on tours they are a participant in" on public.comments
  for select using (exists (select 1 from participants where tour_id = comments.tour_id and user_id = auth.uid()));

create policy "users can create comments on tours they are a participant in" on public.comments
  for insert with check (exists (select 1 from participants where tour_id = comments.tour_id and user_id = auth.uid()));

create policy "users can only update their own comments" on public.comments
  for update using (user_id = auth.uid()) with check (user_id = auth.uid());

create policy "users can only delete their own comments" on public.comments
  for delete using (user_id = auth.uid());

-- votes
create policy "users can view votes on tours they are a participant in" on public.votes
  for select using (exists (select 1 from participants where tour_id = votes.tour_id and user_id = auth.uid()));

create policy "users can vote on tours they participate in" on public.votes
  for insert with check (
    exists (select 1 from participants where tour_id = votes.tour_id and user_id = auth.uid()) and
    not (select are_votes_hidden from tours where id = votes.tour_id)
  );

create policy "users can remove their own vote" on public.votes
  for delete using (
    user_id = auth.uid() and
    not (select are_votes_hidden from tours where id = votes.tour_id)
  );
  
-- invitations
create policy "users can see invitations for tours they own" on public.invitations
  for select using (exists(select 1 from tours where id = invitations.tour_id and owner_id = auth.uid()));

create policy "users can invite others to tours they own" on public.invitations
  for insert with check (inviter_id = auth.uid() and exists(select 1 from tours where id = invitations.tour_id and owner_id = auth.uid()));

create policy "users can delete invitations for tours they own" on public.invitations
  for delete using (exists(select 1 from tours where id = invitations.tour_id and owner_id = auth.uid()));

-- tags
create policy "authenticated users can view tags" on public.tags
  for select using (auth.role() = 'authenticated');

-- tour_tags
create policy "users can view tags for tours they participated in" on public.tour_tags
  for select using (exists (select 1 from participants where tour_id = tour_tags.tour_id and user_id = auth.uid()));

create policy "users can add tags to archived tours they participated in" on public.tour_tags
  for insert with check (
    exists (select 1 from participants where tour_id = tour_tags.tour_id and user_id = auth.uid()) and
    exists (select 1 from tours where id = tour_tags.tour_id and status = 'archived')
  );

commit;
