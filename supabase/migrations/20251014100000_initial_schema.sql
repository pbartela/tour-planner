-- migration: 20251014100000_initial_schema.sql
-- description: sets up the initial database schema for the tour planner application.
-- this migration includes:
--   - creation of all tables: profiles, tours, participants, comments, votes, invitations, tags, tour_tags.
--   - definition of custom enum types for statuses.
--   - setup of row-level security (rls) policies for all tables.
--   - creation of indexes for performance.
--   - implementation of triggers for automatic profile creation and handling user deletion.
--   - insertion of a special 'anonymized' user profile for maintaining comment integrity.

-- a note on the profiles table:
-- the foreign key constraint from 'public.profiles.id' to 'auth.users.id' has been omitted
-- to allow for the creation of a special 'anonymized' user record (uuid: 00000000-...).
-- data integrity for regular users is maintained by a trigger that creates a profile
-- for each new user in 'auth.users'.

begin;

-- custom types
create type public.tour_status as enum ('active', 'archived');
create type public.invitation_status as enum ('pending', 'accepted', 'declined');

-- profiles table
create table public.profiles (
    id uuid primary key,
    display_name text,
    language text not null default 'en',
    theme text not null default 'system',
    onboarding_completed boolean not null default false,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);
comment on table public.profiles is 'stores user profile information, extending the auth.users table.';

alter table public.profiles enable row level security;

-- tours table
create table public.tours (
    id uuid primary key default gen_random_uuid(),
    owner_id uuid not null references public.profiles(id),
    title text not null check (length(title) > 0),
    destination text not null check (length(destination) > 0),
    description text,
    start_date timestamptz not null,
    end_date timestamptz not null,
    participant_limit integer check (participant_limit > 0),
    like_threshold integer check (like_threshold > 0),
    are_votes_hidden boolean not null default false,
    status public.tour_status not null default 'active',
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);
comment on table public.tours is 'contains all information about a tour.';

alter table public.tours enable row level security;

-- participants table
create table public.participants (
    tour_id uuid not null references public.tours(id) on delete cascade,
    user_id uuid not null references public.profiles(id) on delete cascade,
    joined_at timestamptz not null default now(),
    primary key (tour_id, user_id)
);
comment on table public.participants is 'joining table for the many-to-many relationship between profiles and tours.';

alter table public.participants enable row level security;

-- comments table
create table public.comments (
    id uuid primary key default gen_random_uuid(),
    tour_id uuid not null references public.tours(id) on delete cascade,
    user_id uuid not null references public.profiles(id) on delete set default default '00000000-0000-0000-0000-000000000000',
    content text not null check (length(content) > 0),
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);
comment on table public.comments is 'stores comments made by users on tours.';

alter table public.comments enable row level security;

-- votes table
create table public.votes (
    tour_id uuid not null references public.tours(id) on delete cascade,
    user_id uuid not null references public.profiles(id) on delete cascade,
    created_at timestamptz not null default now(),
    primary key (tour_id, user_id)
);
comment on table public.votes is 'stores "likes" from users for a specific tour.';

alter table public.votes enable row level security;

-- invitations table
create table public.invitations (
    id uuid primary key default gen_random_uuid(),
    tour_id uuid not null references public.tours(id) on delete cascade,
    inviter_id uuid not null references public.profiles(id) on delete cascade,
    email text not null,
    status public.invitation_status not null default 'pending',
    created_at timestamptz not null default now()
);
comment on table public.invitations is 'tracks invitations sent to users to join a tour.';

alter table public.invitations enable row level security;

-- tags table
create table public.tags (
    id bigint primary key generated by default as identity,
    name text not null unique check (length(name) > 0)
);
comment on table public.tags is 'stores unique tags for categorizing archived tours.';

alter table public.tags enable row level security;

-- tour_tags table
create table public.tour_tags (
    tour_id uuid not null references public.tours(id) on delete cascade,
    tag_id bigint not null references public.tags(id) on delete cascade,
    primary key (tour_id, tag_id)
);
comment on table public.tour_tags is 'joining table for the many-to-many relationship between tours and tags.';

alter table public.tour_tags enable row level security;

-- anonymized user record
insert into public.profiles (id, display_name)
values ('00000000-0000-0000-0000-000000000000', 'Anonymized User');

-- indexes
create index on public.participants (user_id);
create index on public.comments (tour_id, created_at desc);
create index on public.tour_tags (tag_id);
create index on public.invitations (tour_id, email);

-- function to create a profile for a new user
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id)
  values (new.id);
  return new;
end;
$$;

-- trigger for new user profile creation
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- function to handle user deletion
create or replace function public.handle_user_deletion()
returns trigger
language plpgsql
security definer set search_path = public
as $$
declare
  rec record;
  new_owner_id uuid;
begin
  -- transfer ownership of tours or delete them
  for rec in select id from tours where owner_id = old.id loop
    new_owner_id := (
      select user_id from participants
      where tour_id = rec.id and user_id != old.id
      order by joined_at asc
      limit 1
    );
    if new_owner_id is not null then
      update tours set owner_id = new_owner_id where id = rec.id;
    else
      delete from tours where id = rec.id;
    end if;
  end loop;

  -- delete the user's profile
  delete from public.profiles where id = old.id;
  
  return old;
end;
$$;

-- trigger for user deletion
create trigger on_auth_user_deleted
  before delete on auth.users
  for each row execute procedure public.handle_user_deletion();

-- rls policies

-- profiles
create policy "users can view their own profile" on public.profiles
  for select using (auth.uid() = id);

create policy "users can update their own profile" on public.profiles
  for update using (auth.uid() = id) with check (auth.uid() = id);

-- tours
create policy "users can view tours they are a participant in" on public.tours
  for select using (exists (select 1 from participants where tour_id = tours.id and user_id = auth.uid()));

create policy "authenticated users can create tours" on public.tours
  for insert with check (auth.role() = 'authenticated');

create policy "tour owners can update their tours" on public.tours
  for update using (owner_id = auth.uid()) with check (owner_id = auth.uid());

create policy "tour owners can delete their tours" on public.tours
  for delete using (owner_id = auth.uid());

-- participants
create policy "users can view participants of tours they are in" on public.participants
  for select using (
    auth.uid() in (
      select user_id from participants where tour_id = participants.tour_id
    )
  );

create policy "tour owners can add new participants" on public.participants
  for insert with check (exists (select 1 from tours where id = participants.tour_id and owner_id = auth.uid()));

create policy "users can leave tours, and owners can remove participants" on public.participants
  for delete using (user_id = auth.uid() or exists (select 1 from tours where id = participants.tour_id and owner_id = auth.uid()));

-- comments
create policy "users can read comments on tours they are a participant in" on public.comments
  for select using (exists (select 1 from participants where tour_id = comments.tour_id and user_id = auth.uid()));

create policy "users can create comments on tours they are a participant in" on public.comments
  for insert with check (exists (select 1 from participants where tour_id = comments.tour_id and user_id = auth.uid()));

create policy "users can only update their own comments" on public.comments
  for update using (user_id = auth.uid()) with check (user_id = auth.uid());

create policy "users can only delete their own comments" on public.comments
  for delete using (user_id = auth.uid());

-- votes
create policy "users can view votes on tours they are a participant in" on public.votes
  for select using (exists (select 1 from participants where tour_id = votes.tour_id and user_id = auth.uid()));

create policy "users can vote on tours they participate in" on public.votes
  for insert with check (
    exists (select 1 from participants where tour_id = votes.tour_id and user_id = auth.uid()) and
    not (select are_votes_hidden from tours where id = votes.tour_id)
  );

create policy "users can remove their own vote" on public.votes
  for delete using (
    user_id = auth.uid() and
    not (select are_votes_hidden from tours where id = votes.tour_id)
  );
  
-- invitations
create policy "users can see invitations for tours they own" on public.invitations
  for select using (exists(select 1 from tours where id = invitations.tour_id and owner_id = auth.uid()));

create policy "users can invite others to tours they own" on public.invitations
  for insert with check (inviter_id = auth.uid() and exists(select 1 from tours where id = invitations.tour_id and owner_id = auth.uid()));

create policy "users can delete invitations for tours they own" on public.invitations
  for delete using (exists(select 1 from tours where id = invitations.tour_id and owner_id = auth.uid()));

-- tags
create policy "authenticated users can view tags" on public.tags
  for select using (auth.role() = 'authenticated');

-- tour_tags
create policy "users can view tags for tours they participated in" on public.tour_tags
  for select using (exists (select 1 from participants where tour_id = tour_tags.tour_id and user_id = auth.uid()));

create policy "users can add tags to archived tours they participated in" on public.tour_tags
  for insert with check (
    exists (select 1 from participants where tour_id = tour_tags.tour_id and user_id = auth.uid()) and
    exists (select 1 from tours where id = tour_tags.tour_id and status = 'archived')
  );

commit;
